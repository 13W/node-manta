#!/usr/bin/env node
// -*- mode: js -*-
// Copyright (c) 2012, Joyent, Inc. All rights reserved.

var path = require('path');
var url = require('url');

var bunyan = require('bunyan');
var getopt = require('posix-getopt');
var restify = require('restify');
var uuid = require('node-uuid');

var manta = require('../lib');



///--- Globals

var LOG = bunyan.createLogger({
        name: path.basename(process.argv[1]),
        level: (process.env.LOG_LEVEL || 'info'),
        stream: process.stderr,
        serializers: restify.bunyan.serializers
});

var optionsMsg = [
        'OPTIONS:',
        '  jobId        (required) job UUID',
        '  -a account   Manta account (specify this or export MANTA_USER)',
        '  -c           cancel job',
        '  -e           end input for job',
        '  -f           list failed input keys',
        '  -i           list input keys',
        '  -k keyId     SSH fingerprint (specify this or export MANTA_KEY_ID)',
        '  -o           list output',
        '  -u url       Manta URL (specify this or export MANTA_URL)',
        '  -v           verbose mode',
        '  -x           print job errors'
].join('\n');


///--- Functions

function ifError(err) {
        if (err) {
                console.error(err.stack);
                process.exit(1);
        }
}


function inputStream(client, id, opts) {
        opts = opts || {};
        client.jobInput(id, opts, function stream(err, out) {
                ifError(err);

                var last;
                var seen = 0;
                var total = 0;

                out.on('key', function (k) {
                        if (k === opts.marker)
                                return;

                        last = k;
                        seen++;
                        console.log(k);
                });

                out.on('err', function (e) {
                        console.log(JSON.stringify(e));
                });

                out.once('end', function () {
                        if (seen < total && last) {
                                inputStream(client, id, {marker: last});
                        } else {
                                process.exit(0);
                        }
                });

                out.once('result', function (res) {
                        if (res.statusCode !== 200)
                                return;
                        total = parseInt(res.headers['result-set-size'] || 0,
                                         10);
                });
        });
}


function parseOptions() {
        var option;
        var opts = {
                log: LOG
        };
        var parser = new getopt.BasicParser('vcefiohxk:u:a:',
                                            process.argv);

        while ((option = parser.getopt()) !== undefined && !option.error) {
                switch (option.option) {
                case 'a':
                        opts.user = option.optarg;
                        break;

                case 'c':
                        opts.cancel = true;
                        break;

                case 'e':
                        opts.end = true;
                        break;

                case 'f':
                        opts.fail = true;
                        break;

                case 'h':
                        usage();
                        break;

                case 'i':
                        opts.input = true;
                        break;

                case 'k':
                        opts.keyId = option.optarg;
                        break;

                case 'o':
                        opts.output = true;
                        break;

                case 'u':
                        opts.url = url.parse(option.optarg).href;
                        break;

                case 'v':
                        // Allows us to set -vvv -> this little hackery
                        // just ensures that we're never < TRACE
                        LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
                        if (LOG.level() <= bunyan.DEBUG)
                                LOG = LOG.child({src: true});
                        break;

                case 'x':
                        opts.errors = true;
                        break;

                default:
                        usage('invalid argument: ' + option.option);
                        process.exit(1);
                        break;
                }
        }

        if (option && option.error)
                usage('\n');

        try {
                manta.checkBinEnv(opts);
        } catch (err) {
                usage(err.message);
        }


        if ((opts.input || opts.output || opts.fail) &&
            !xor(opts.fail, opts.input, opts.output)) {
                usage('-f, -i and -o are mutually exclusive');
        }

        if ((opts.end || opts.cancel) && !xor(opts.end, opts.cancel)) {
                usage('-c and -e are mutually exclusive');
        }

        if (parser.optind() >= process.argv.length)
                usage('missing required argument: "jobId"');

        opts.id = process.argv[parser.optind()];

        return (opts);
}


function usage(msg) {
        if (msg)
                console.error(msg);

        var str = 'usage: ' + path.basename(process.argv[1]);
        str += ' [-v] [-a account] [-u url] [-k keyId] [-c] [-e] [-o] ';
        str += '[-f] [-i] [-x] jobId';
        console.error(str);
        console.error(optionsMsg);
        process.exit(msg ? 1 : 0);
}


function xor() {
        var b = false;
        for (var i = 0; i < arguments.length; i++) {
                if (arguments[i] && !b) {
                        b = (true);
                } else if (arguments[i] && b) {
                        return (false);
                }
        }
        return (b);
}



///--- Mainline

(function main() {
        var options = parseOptions();
        var client = manta.createBinClient(options);

        client.job(options.id, function (job_err, job) {
                ifError(job_err);

                function cb(err) {
                        ifError(err);

                        process.exit(0);
                }

                function streamOut(err, out) {
                        ifError(err);

                        out.once('end', cb.bind(null, null));
                        out.on('err', function (e) {
                                console.log(JSON.stringify(e));
                        });
                        out.on('key', function (k) {
                                console.log(k);
                        });
                }

                if (options.output) {
                        client.jobOutput(options.id, streamOut);
                } else if (options.input) {
                        inputStream(client, options.id);
                } else if (options.fail) {
                        client.jobFailures(options.id, streamOut);
                } else if (options.errors) {
                        client.jobErrors(options.id, streamOut);
                } else if (options.end) {
                        client.endJob(options.id, cb);
                } else if (options.cancel) {
                        client.cancelJob(options.id, cb);
                } else {
                        if (!job.inputDone)
                                console.error('warning: job input not done');

                        console.log(JSON.stringify(job, null, 2));
                        cb();
                }
        });
})();
