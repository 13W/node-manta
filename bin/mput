#!/usr/bin/env node
// -*- mode: js -*-
// vim: set expandtab sw=8
// Copyright (c) 2012, Joyent, Inc. All rights reserved.

var fs = require('fs');
var path = require('path');
var url = require('url');

var bunyan = require('bunyan');
var dashdash = require('dashdash');
var restify = require('restify');
var uuid = require('node-uuid');

var manta = require('../lib');



///--- Globals

var LOG = bunyan.createLogger({
    name: path.basename(process.argv[1]),
    level: (process.env.LOG_LEVEL || 'info'),
    stream: process.stderr,
    serializers: restify.bunyan.serializers
});

var OPTIONS_PARSER = dashdash.createParser({
    options: manta.DEFAULT_CLI_OPTIONS.concat([
        {
            names: ['copies', 'c'],
            type: 'positiveInteger',
            help: 'number of copies to make',
            helpArg: 'COPIES',
            'default': 2
        },
        {
            names: ['file', 'f'],
            type: 'string',
            help: 'local file to upload',
            helpArg: 'FILE'
        },
        {
            names: ['header', 'H'],
            type: 'arrayOfString',
            help: 'HTTP headers to include',
            helpArg: 'HEADER'
        },
        {
            names: ['quiet', 'q'],
            type: 'bool',
            help: 'disable the progress bar'
        }
    ])
});



///--- Functions

function ifError(err) {
    if (!err)
        return;

    if (err.name === 'OperationNotAllowedOnRootDirectoryError' ||
        err.name === 'OperationNotAllowedOnDirectoryError') {
        console.error('Cannot mput to a directory; ' +
                      'specify full object path');
    } else {
        console.error(err.toString());
    }

    process.exit(1);
}


function parseOptions() {
    var opts;

    try {
        opts = OPTIONS_PARSER.parse(process.argv);
        manta.checkBinEnv(opts);
    } catch (e) {
        manta.cli_usage(OPTIONS_PARSER, e.message, 'path...');
    }

    manta.cli_logger(opts, LOG);

    if (opts.help)
        manta.cli_usage(OPTIONS_PARSER, false, 'path...');

    if (opts._args.length < 1)
        manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');

    opts.path = opts._args[0];

    opts.headers = {};
    (opts.header || []).forEach(function (h) {
        if (h.indexOf(':') === -1) {
            manta.cli_usage(OPTIONS_PARSER,
                            'header must be in the form of "[header]: value"',
                            'path...');
        }
        var tmp = h.split(':');
        opts.headers[tmp[0]] = tmp[1].trim();
    });

    return (opts);
}


function printEntry(obj) {
    console.log('%j', obj);
}



///--- Mainline

(function main() {
    var bar = null;
    var options = parseOptions();

    var client = manta.createBinClient(options);
    var opts = {
        copies: options.copies,
        headers: options.headers
    };

    function put(stream) {
        client.put(options.path, stream, opts, function (err) {
            ifError(err);
            client.close();
        });
    }

    if (options.file) {
        fs.stat(options.file, function (err, stats) {
            ifError(err);

            if (!stats.isFile()) {
                console.error(options.file + ' is not a file');
                process.exit(1);
            }

            opts.size = stats.size;
            var fstream = fs.createReadStream(options.file);
            fstream.pause();
            fstream.on('open', function () {
                put(fstream);
            });
            if (!options.quiet && Boolean(process.stderr.isTTY)) {
                bar = new manta.ProgressBar({
                    filename: options.path,
                    size: stats.size
                });
                fstream.on('data', function (data) {
                    bar.advance(data.length);
                });
                fstream.once('end', function () {
                    bar.end();
                });
            }
        });
    } else {
        if (!options.quiet && Boolean(process.stderr.isTTY)) {
            bar = new manta.ProgressBar({
                filename: options.path,
                nosize: true
            });
            process.stdin.on('data', function (data) {
                bar.advance(data.length);
            });
            process.stdin.once('end', function () {
                bar.end();
            });
        }
        put(process.stdin);
    }
})();
