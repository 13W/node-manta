#!/usr/bin/env node
// -*- mode: js -*-
// Copyright (c) 2013, Joyent, Inc. All rights reserved.

var fs = require('fs');
var path = require('path');
var url = require('url');

var bunyan = require('bunyan');
var dashdash = require('dashdash');
var once = require('once');
var restify = require('restify');
var vasync = require('vasync');
var uuid = require('node-uuid');

var manta = require('../lib');



///--- Globals

var LOG = bunyan.createLogger({
    name: path.basename(process.argv[1]),
    level: (process.env.LOG_LEVEL || 'info'),
    stream: process.stderr,
    serializers: restify.bunyan.serializers
});


var OPTIONS_PARSER = dashdash.createParser({
    options: manta.DEFAULT_CLI_OPTIONS.concat([
        {
            names: ['copies', 'c'],
            type: 'positiveInteger',
            help: 'number of copies to make',
            helpArg: 'COPIES',
            'default': 2
        },
        {
            names: ['depth', 'd'],
            type: 'positiveInteger',
            help: 'how deep to recurse on local sync',
            helpArg: 'DEPTH'
        },
        {
            names: ['header', 'H'],
            type: 'arrayOfString',
            help: 'HTTP headers to include',
            helpArg: 'HEADER'
        },
        {
            names: ['noop', 'n'],
            type: 'bool',
            help: 'No-Op: Only show what would be done'
        },
        {
            names: ['parallel', 'p'],
            type: 'positiveInteger',
            help: 'limit concurrent operations (default 100)',
            'default': 100,
            helpArg: 'CONCURRENCY'
        },
        {
            names: ['remote', 'r'],
            type: 'bool',
            help: 'perform a remote sync'
        }
    ])
});



///--- Functions

function ifError(err) {
    if (err) {
        console.error('msync: ' + err.toString());
        process.exit(1);
    }
}


function localList(opts, callback) {
    callback = once(callback);

    fs.readdir(opts.source, function (read_err, files) {
        if (read_err) {
            callback(read_err);
            return;
        }

        vasync.forEachParallel({
            func: function stat(f, cb) {
                cb = once(cb);
                f = opts.source + '/' + f;
                var f2 = path.resolve(f);
                fs.stat(f2, function (err, stats) {
                    if (err) {
                        cb(err);
                        return;
                    }

                    if (opts.depth >= 1) {
                        var r = opts.root;
                        var tmp = path.relative(r, f2);
                        tmp = tmp.split('/');
                        if (tmp.length > opts.depth) {
                            cb();
                            return;
                        }
                    }

                    if (stats.isFile()) {
                        opts.files.push({
                            file: f,
                            size: stats.size
                        });
                        cb();
                    } else if (stats.isDirectory()) {
                        opts.dirs.push(f);
                        localList({
                            depth: opts.depth,
                            dirs: opts.dirs,
                            files: opts.files,
                            root: opts.root,
                            source: f
                        }, cb);
                    } else {
                        cb();
                    }
                });
            },
            inputs: files
        }, callback);
    });
}

function remoteList(client, options, callback) {
    callback = once(callback);

    var queue = new manta.Queue({
        limit: options.parallel,
        worker: function ls(opts, cb) {
            var last;
            var _opts = {
                query: {}
            };

            if (options.limit)
                _opts.query.limit = options.limit;
            if (opts.marker)
                _opts.query.marker = opts.marker;

            client.ls(opts.path, _opts, function (err, res) {
                ifError(err);

                res.on('directory', function onDirectory(dir) {
                    if (dir.name === opts.marker)
                        return;

                    var p = opts.path + '/' + dir.name;
                    var q = p.substr(options.path.length);
                    var dirName = options.dest + '/' + q;
                    options.dirs.push(dirName);
                    last = dir.name;
                    queue.push({
                        client: client,
                        path: p,
                        type: options.type
                    });
                });

                res.on('object', function onObject(obj) {
                    if (obj.name === opts.marker)
                        return;

                    last = obj.name;
                    var p = opts.path + '/' + obj.name;
                    var q = p.substr(options.path.length);
                    var lname = options.dest + q;
                    options.files.push({remoteName: p,
                                        localName: lname});
                });

                res.once('error', ifError);

                res.once('end', function onEnd(http_res) {
                    if (last) {
                        queue.push({
                            marker: last,
                            path: opts.path,
                            type: opts.type
                        });
                    }
                    cb();
                });
            });
        }
    });

    client.info(options.path, function (err, info) {
        if (err) {
            client.get(options.path, function (err2) {
                ifError(err2);
                // We *shouldn't* ever hit this...
                ifError(err);
            });
            return;
        }

        if (info.extension === 'directory') {
            queue.push(options);
        }
    });

    queue.once('drain', function () {
        queue.once('end', client.close.bind(client));
        queue.close();
        callback();
    });
}


function parseOptions() {
    var opts;

    try {
        opts = OPTIONS_PARSER.parse(process.argv);
        manta.checkBinEnv(opts);
    } catch (e) {
        manta.cli_usage(OPTIONS_PARSER, e.message, 'source path');
    }

    manta.cli_logger(opts, LOG);

    if (opts.help)
        manta.cli_usage(OPTIONS_PARSER, false, 'source path');

    if (opts._args.length < 1)
        manta.cli_usage(OPTIONS_PARSER, 'source required', 'source path');

    if (opts._args.length < 2)
        manta.cli_usage(OPTIONS_PARSER, 'path required', 'source path');

    opts.source = opts._args[0];
    opts.path = opts._args[1];

    opts.headers = {};
    (opts.header || []).forEach(function (h) {
        if (h.indexOf(':') === -1) {
            manta.cli_usage(OPTIONS_PARSER,
                            'header must be in the form of "[header]: value"',
                            'path...');
        }
        var tmp = h.split(':');
        opts.headers[tmp[0]] = tmp[1].trim();
    });

    return (opts);
}


function printEntry(obj) {
    console.log('%j', obj);
}



///--- Mainline

(function main() {
    var options = parseOptions();
    var client = manta.createBinClient(options);

    var localDirQ = new manta.Queue({
        limit: 1,
        worker: function (d, cb) {

            if (options.noop === undefined) {
                fs.mkdirSync(d);
            } else {
                console.log('mkdir: ' + d);
            }

            var nxt = options.dirs.shift();
            if (nxt) {
                localDirQ.push(nxt);
            } else {
                localDirQ.close();
            }
            cb();
        }
    });

    var remoteDirQ = new manta.Queue({
        limit: 1,
        worker: function (d, cb) {
            var p = options.path + '/' + d;
            if (options.noop === undefined) {
                client.mkdir(p, function (err) {
                    if (err) {
                        cb(err);
                        return;
                    }
                    var xt = options.dirs.shift();
                    if (xt) {
                        remoteDirQ.push(xt);
                    } else {
                        remoteDirQ.close();
                    }
                    cb();
                });
            } else {
                console.log(p);
                var nxt = options.dirs.shift();
                if (nxt) {
                    remoteDirQ.push(nxt);
                } else {
                    remoteDirQ.close();
                }
                cb();
            }
        }
    });

    var downloadFileQ = new manta.Queue({
        limit: options.parallel,
        worker: function get(opts, cb) {
            cb = once(cb);

            if (options.noop === undefined) {
                var out = fs.createWriteStream(opts.localName);

                var rn = opts.remoteName;
                client.get(rn, function (err, stream, res) {
                    ifError(err);

                    stream.on('data', function (data) {
                        out.write(data);
                    });
                    stream.on('end', function () {
                        out.destroySoon();
                        cb();
                    });
                });
            } else {
                console.log('get: '+opts.remoteName);
            }
        }
    });

    var uploadFileQ = new manta.Queue({
        limit: options.parallel,
        worker: function put(opts, cb) {
            cb = once(cb);

            var p = options.path + '/' + opts.file;
            var _opts = {
                copies: options.copies,
                size: opts.size
            };
            if (options.noop === undefined) {
                var stream = fs.createReadStream(opts.file);
                stream.pause();
                stream.once('open', function () {
                    client.put(p, stream, _opts, cb);
                });
            } else {
                console.log(p);
            }

        }
    });

    function pushFiles() {
        options.files.forEach(function (f) {
            uploadFileQ.push(f);
        });
        uploadFileQ.once('end', process.exit.bind(process, 0));
        uploadFileQ.close();
    }

    function pullFiles() {
        options.files.forEach(function (f) {
            downloadFileQ.push(f);
        });
        downloadFileQ.once('end', process.exit.bind(process, 0));
        downloadFileQ.close();
    }

    if (options.remote === undefined) {
        options.root = path.resolve(options.source);
        options.dirs = [path.basename(options.root)];
        options.files = [];
    } else {
        options.dest = path.resolve(options.source);
        options.dirs = [];
        options.files = [];
    }


    if (options.remote === undefined) {
        localList(options, function (err) {
            ifError(err);

            if (options.dirs.length) {
                remoteDirQ.once('end', pushFiles);

                options.dirs.sort();
                remoteDirQ.push(options.dirs.shift());
            } else {
                remoteDirQ.close();
                pushFiles();
            }
        });
    } else {
        remoteList(client, options, function (err) {
            ifError(err);

            if (options.dirs.length) {
                localDirQ.once('end', pullFiles);

                options.dirs.sort();
                localDirQ.push(options.dirs.shift());
            } else {
                localDirQ.close();
                pullFiles();
            }
        });
    }

})();
